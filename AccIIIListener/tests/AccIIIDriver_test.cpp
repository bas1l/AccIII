/*
 * AccIIIDriver_test.cpp
 *
 *  Created on: Aug 16, 2020
 *      Author: Basil Duvernoy
 */

#define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file
#include "../libs/catch.hpp"

#include "../include/AccIIIListener/AccIIIDriverMock.h"

TEST_CASE("AccIIIDriver::constant global variables", "[equality tests]") {

    REQUIRE(ACCIII_NB_SENSORS == 46);
    REQUIRE(ACCIII_NB_GROUP == 2);
    REQUIRE(ACCIII_NB_AXIS == 3);
    REQUIRE(ACCIII_NB_BYTEPERVALUE == 2);
    REQUIRE(ACCIII_NB_SENSORSPERGROUP == 23);
    REQUIRE(ACCIII_NB_BYTEPERGROUP == 138);
    REQUIRE(ACCIII_NB_BYTEPERFRAME == 276);
    REQUIRE(ACCIII_OFFSET_HIGHBYTE == 23);
    REQUIRE(ACCIII_VALUE_MAX == 65535);
    REQUIRE(ACCIII_VALUE_MID == 32768);
}

TEST_CASE("AccIIIDriver::Tests", "[Byte, uint8_t, int16_t]") {

    AccIIIDriverMock* ad = new AccIIIDriverMock();

    SECTION("Byte to uint8_t") {
        REQUIRE(ad->byte2uint8(0x00) == 0);
        REQUIRE(ad->byte2uint8(0x01) == 1);
        REQUIRE(ad->byte2uint8(0x80) == 128);
        REQUIRE(ad->byte2uint8(0xFF) == 255);
    }

    SECTION("uint8_t to Byte") {
        REQUIRE(ad->uint2byte(0) == 0x00);
        REQUIRE(ad->uint2byte(1) == 0x01);
        REQUIRE(ad->uint2byte(128) == 0x80);
        REQUIRE(ad->uint2byte(255) == 0xFF);
    }

    SECTION("uint8_t to uint16_t") {
        REQUIRE(ad->bytes2uint16(0x00, 0xFF) == 255);
        REQUIRE(ad->bytes2uint16(0x01, 0xFF) == 511);
        REQUIRE(ad->bytes2uint16(0x80, 0x00) == ACCIII_VALUE_MID);
        REQUIRE(ad->bytes2uint16(0xFF, 0xFF) == ACCIII_VALUE_MAX);
    }

    SECTION("uint16_t to int16_t") {
        REQUIRE(ad->uint16toint16(ACCIII_VALUE_MAX) == -1);
        REQUIRE(ad->uint16toint16(ACCIII_VALUE_MID) == -32768);
        REQUIRE(ad->uint16toint16(0) == 0);
    }

    SECTION("std::Queue<Byte> to decoded Queue<Int>") {
        std::deque<Byte> res;
        long l = ACCIII_NB_BYTEPERFRAME;


        SECTION("std::Queue<Byte> to decoded Queue<Int>:: Basic") {
            Byte cp[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //odd,Xl
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //odd,Xh
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //odd,Yl
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //odd,Yh
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //odd,Zl
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //odd,Zh
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //even,Xl
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //even,Xh
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //even,Yl
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //even,Yh
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //even,Zl
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };//even,Zh

            std::deque<Byte> cp_deque(cp, cp + sizeof(cp) / sizeof(Byte));

            ad->addtoReceivedBytes(cp, l);
            res = ad->getReceivedBytes();

            REQUIRE(res == cp_deque);

            std::vector<int16_t> data1D_zeros(3, 0);
            vector2D_int data2D_zeros(46, data1D_zeros);
            vector3D_int data3D_zeros(1, data2D_zeros);

            ad->addtoAccData(ad->getReceivedBytes());
            vector3D_int data = ad->getAccData();

            REQUIRE(data == data3D_zeros);
        }

        SECTION("std::Queue<Byte> to decoded Queue<Int>:: One") {
            Byte cp[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //odd,Xl
                          0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //odd,Xh
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //odd,Yl
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //odd,Yh
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //odd,Zl
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //odd,Zh
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //even,Xl
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //even,Xh
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //even,Yl
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //even,Yh
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //even,Zl
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };//even,Zh

            std::deque<Byte> cp_deque(cp, cp + sizeof(cp) / sizeof(Byte));

            ad->addtoReceivedBytes(cp, l);
            res = ad->getReceivedBytes();

            REQUIRE(res == cp_deque);

            std::vector<int16_t> data1D_zeros(3, 0);
            vector2D_int data2D_zeros(46, data1D_zeros);
            vector3D_int data3D_zeros(1, data2D_zeros);
            data3D_zeros[0][0][0] = 4096;

            ad->addtoAccData(ad->getReceivedBytes());
            vector3D_int data = ad->getAccData();

            REQUIRE(data == data3D_zeros);
        }
    }
    
}

